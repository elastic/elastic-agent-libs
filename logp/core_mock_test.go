// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package logp

import (
	"sync"

	"go.uber.org/zap/zapcore"
)

// ZapCoreMock is a mock implementation of zapcore.Core.
//
//	func TestSomethingThatUsesCore(t *testing.T) {
//
//		// make and configure a mocked zapcore.Core
//		mockedCore := &ZapCoreMock{
//			CheckFunc: func(entry zapcore.Entry, checkedEntry *zapcore.CheckedEntry) *zapcore.CheckedEntry {
//				panic("mock out the Check method")
//			},
//			EnabledFunc: func(level zapcore.Level) bool {
//				panic("mock out the Enabled method")
//			},
//			SyncFunc: func() error {
//				panic("mock out the Sync method")
//			},
//			WithFunc: func(fields []zapcore.Field) zapcore.Core {
//				panic("mock out the With method")
//			},
//			WriteFunc: func(entry zapcore.Entry, fields []zapcore.Field) error {
//				panic("mock out the Write method")
//			},
//		}
//
//		// use mockedCore in code that requires zapcore.Core
//		// and then make assertions.
//
//	}
type ZapCoreMock struct {
	// CheckFunc mocks the Check method.
	CheckFunc func(entry zapcore.Entry, checkedEntry *zapcore.CheckedEntry) *zapcore.CheckedEntry

	// EnabledFunc mocks the Enabled method.
	EnabledFunc func(level zapcore.Level) bool

	// SyncFunc mocks the Sync method.
	SyncFunc func() error

	// WithFunc mocks the With method.
	WithFunc func(fields []zapcore.Field) zapcore.Core

	// WriteFunc mocks the Write method.
	WriteFunc func(entry zapcore.Entry, fields []zapcore.Field) error

	// calls tracks calls to the methods.
	calls struct {
		// Check holds details about calls to the Check method.
		Check []struct {
			// Entry is the entry argument value.
			Entry zapcore.Entry
			// CheckedEntry is the checkedEntry argument value.
			CheckedEntry *zapcore.CheckedEntry
		}
		// Enabled holds details about calls to the Enabled method.
		Enabled []struct {
			// Level is the level argument value.
			Level zapcore.Level
		}
		// Sync holds details about calls to the Sync method.
		Sync []struct {
		}
		// With holds details about calls to the With method.
		With []struct {
			// Fields is the fields argument value.
			Fields []zapcore.Field
		}
		// Write holds details about calls to the Write method.
		Write []struct {
			// Entry is the entry argument value.
			Entry zapcore.Entry
			// Fields is the fields argument value.
			Fields []zapcore.Field
		}
	}
	lockCheck   sync.RWMutex
	lockEnabled sync.RWMutex
	lockSync    sync.RWMutex
	lockWith    sync.RWMutex
	lockWrite   sync.RWMutex
}

// Check calls CheckFunc.
func (mock *ZapCoreMock) Check(entry zapcore.Entry, checkedEntry *zapcore.CheckedEntry) *zapcore.CheckedEntry {
	if mock.CheckFunc == nil {
		panic("ZapCoreMock.CheckFunc: method is nil but Core.Check was just called")
	}
	callInfo := struct {
		Entry        zapcore.Entry
		CheckedEntry *zapcore.CheckedEntry
	}{
		Entry:        entry,
		CheckedEntry: checkedEntry,
	}
	mock.lockCheck.Lock()
	mock.calls.Check = append(mock.calls.Check, callInfo)
	mock.lockCheck.Unlock()
	return mock.CheckFunc(entry, checkedEntry)
}

// CheckCalls gets all the calls that were made to Check.
// Check the length with:
//
//	len(mockedCore.CheckCalls())
func (mock *ZapCoreMock) CheckCalls() []struct {
	Entry        zapcore.Entry
	CheckedEntry *zapcore.CheckedEntry
} {
	var calls []struct {
		Entry        zapcore.Entry
		CheckedEntry *zapcore.CheckedEntry
	}
	mock.lockCheck.RLock()
	calls = mock.calls.Check
	mock.lockCheck.RUnlock()
	return calls
}

// Enabled calls EnabledFunc.
func (mock *ZapCoreMock) Enabled(level zapcore.Level) bool {
	if mock.EnabledFunc == nil {
		panic("ZapCoreMock.EnabledFunc: method is nil but Core.Enabled was just called")
	}
	callInfo := struct {
		Level zapcore.Level
	}{
		Level: level,
	}
	mock.lockEnabled.Lock()
	mock.calls.Enabled = append(mock.calls.Enabled, callInfo)
	mock.lockEnabled.Unlock()
	return mock.EnabledFunc(level)
}

// EnabledCalls gets all the calls that were made to Enabled.
// Check the length with:
//
//	len(mockedCore.EnabledCalls())
func (mock *ZapCoreMock) EnabledCalls() []struct {
	Level zapcore.Level
} {
	var calls []struct {
		Level zapcore.Level
	}
	mock.lockEnabled.RLock()
	calls = mock.calls.Enabled
	mock.lockEnabled.RUnlock()
	return calls
}

// Sync calls SyncFunc.
func (mock *ZapCoreMock) Sync() error {
	if mock.SyncFunc == nil {
		panic("ZapCoreMock.SyncFunc: method is nil but Core.Sync was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSync.Lock()
	mock.calls.Sync = append(mock.calls.Sync, callInfo)
	mock.lockSync.Unlock()
	return mock.SyncFunc()
}

// SyncCalls gets all the calls that were made to Sync.
// Check the length with:
//
//	len(mockedCore.SyncCalls())
func (mock *ZapCoreMock) SyncCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSync.RLock()
	calls = mock.calls.Sync
	mock.lockSync.RUnlock()
	return calls
}

// With calls WithFunc.
func (mock *ZapCoreMock) With(fields []zapcore.Field) zapcore.Core {
	if mock.WithFunc == nil {
		panic("ZapCoreMock.WithFunc: method is nil but Core.With was just called")
	}
	callInfo := struct {
		Fields []zapcore.Field
	}{
		Fields: fields,
	}
	mock.lockWith.Lock()
	mock.calls.With = append(mock.calls.With, callInfo)
	mock.lockWith.Unlock()
	return mock.WithFunc(fields)
}

// WithCalls gets all the calls that were made to With.
// Check the length with:
//
//	len(mockedCore.WithCalls())
func (mock *ZapCoreMock) WithCalls() []struct {
	Fields []zapcore.Field
} {
	var calls []struct {
		Fields []zapcore.Field
	}
	mock.lockWith.RLock()
	calls = mock.calls.With
	mock.lockWith.RUnlock()
	return calls
}

// Write calls WriteFunc.
func (mock *ZapCoreMock) Write(entry zapcore.Entry, fields []zapcore.Field) error {
	if mock.WriteFunc == nil {
		panic("ZapCoreMock.WriteFunc: method is nil but Core.Write was just called")
	}
	callInfo := struct {
		Entry  zapcore.Entry
		Fields []zapcore.Field
	}{
		Entry:  entry,
		Fields: fields,
	}
	mock.lockWrite.Lock()
	mock.calls.Write = append(mock.calls.Write, callInfo)
	mock.lockWrite.Unlock()
	return mock.WriteFunc(entry, fields)
}

// WriteCalls gets all the calls that were made to Write.
// Check the length with:
//
//	len(mockedCore.WriteCalls())
func (mock *ZapCoreMock) WriteCalls() []struct {
	Entry  zapcore.Entry
	Fields []zapcore.Field
} {
	var calls []struct {
		Entry  zapcore.Entry
		Fields []zapcore.Field
	}
	mock.lockWrite.RLock()
	calls = mock.calls.Write
	mock.lockWrite.RUnlock()
	return calls
}
